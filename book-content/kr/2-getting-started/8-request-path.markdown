# 요청 경로

* This will become a table of contents (this text will be scraped).
{:toc}
모든 웹어플리케이션은 클라이언트의 HTTP요청의 응답으로 작동합니다.
각 액션은 HTTP서버로부터의 응답과 함께 끝납니다.
이 장에서는, 클라이언트의 요청에 대한 응답을 통해 프로그램 흐름을 따라가보도록 하겠습니다.

## 클라이언트에서 문앞까지{: #from_the_client_to_our_doorstep}

인터넷의 내부 동작들을 설명하는 것은 이 책의 범위를 벗어납니다.
하지만 클라이언트(예, 웹브라우저)가  생성하는 몇가지 엔터티들(프록시, 캐시, 파이어월)을 통해 서버에 요청하는 것들을 기억하는 것은 도움이 될 것입니다.
이러한 엔터티들은 요청을 보고, 수정하고, 우리가 다시 보내는 것들을 아마 저장할 것입니다.
만약 모두 잘 작동한다면, 유저에게 투명할 것이고 서버에는 어떤 우려도 없을 것입니다.

하지만 (특히 동적인 사이트들)에는 이러한 동작들이 어카운트로 되야하는 상황들이 생깁니다.
서버의 부하를 줄이기 위한 인터넷의 인프라를 통해 어드벤티지를 얻는 방법들이 있습니다.
이 방법들은 대역폭과 장비가격을 낮춰줄 수 있습니다.

## 리버스 프록시(optional){: #reverse_proxy_optional}

작동되는 어플리케이션에서 처음으로 멈추는 것은 보통 [NginX][]나 [Apache][]의 [mod\_proxy][] 같은 리버스 프록시입니다.
어떻게 세팅했느냐에 따라서 이러한 프록시들은 정적인 파일들(예, 이미지, CSS스타일 시트, 자바스크립트 코드, 동영상)을 제공할 것입니다.
우리는 종종 어플리케이션이 어떤 방해도 받지 않고 캐시된 페이지들을 제공할 수 있도록 프록시를  허락합니다.

[Phusion Passenger][]는 본질적으로 리버스 프록시는 아닙니다만, 논의를 하기위해 그렇다고 가정해보겠습니다.
(구체적으로 말씀드리면, 아파치를 통해 요청을 받고 [Rack][]을 경유하여 서버 어플리케이션에게 요청을 보냅니다.)

## 웹서버{: #web_server}

만약 요청이 이미 리버스 프록시에 의해 리턴되지 않았거나 어떤 리버스 프록시도 사용되고 있지 않다면, 
요청은 **웹서버**로 포워딩될 것입니다.
[Mongrel][], [Thin][], [Ebb][], 그리고 여타 다른 프로그램들이 이 역할을 매워줍니다.

웹서버가 응답을 받게 되면 파싱한 후, 핸들러를 통해 요청을 [Rack][]에게 보냅니다.

## Rack과 Merb{: #rack_and_merb}

Merb는 요청을 [Rack][]환경으로 받아들입니다.
Rack환경은 요청을 위해 모든 CGI 스타일의 헤더들을 감쌉니다.
왜냐하면 Merb는 Rack을 추상레이어로 사용하여 웹서버를 바꾸는 것이 매우 쉽기 때문입니다.
여러분은 아마 사람들이 이러한 웹서버들을 어답터라고 부르는 것을 들어보셨을 것입니다.

Merb가 스택을 통해 요청을 디스패치하기 전에 "Rack 미들웨어"를 더할 수 있습니다.
Rack 미들웨어는 Merb에게 요청이 들어가기 전에 요청을 프로세스할 수 있습니다.
또한, 요청을 "감싸"서 커스텀코드가 요청이 스택을 통해 들어가기 전이나 후에 실행되도록 할 수 있습니다.
Rack 미들웨어는 여러분들이 커스텀 로깅이나 캐싱, 프로파일들을 할 수 있게 해주는 아주 강력한 툴입니다.

Rack의 사용법에 대해서 살펴보지는 않겠습니다만, (Merb풀 스택 어플리케이션의 경우) ``config/rack.rb``파일에서 Merb의 Rack셋업을 찾을 수 있으실 것입니다.

## 라우터{: #router}

스택에 요청이 보내지면 요청에의해 어디로 가야할 것인지 라우터에게 물어보게 됩니다.
그다음 요청은 자신을 컨트롤러에 보내게 됩니다.

라우터의 일은 요청에 의해 추출된 패러미터들을 설정하고 요청이 어디로 가야할 것인지를 말해주는 것입니다.
대개의 경우, 라우터는 컨트롤러 메소드(액션)에 요청을 매핑하고, 또한 요청에서 추출한 패러미터를 설정합니다.

보이지 않는 곳에서는 Merb 프레임웍이 여러분들을 위해 이미 몇가지 일들을 해놓았습니다.
요청이 컨트롤러에 도달하게 되면 Merb는:

* 요청에 대한 URI 경로를 추출합니다.
* 클라이언트로부터 보내진 Post나 Query데이터를 파싱하고, 그 결과를 ``params``해시에 저장합니다.
* 현재 세션과 요청 쿠키에 대한 접근을 설정합니다.

개발자는 요청을 라우팅하기 위해 이러한 정보들을 사용할 수 있습니다.
더 자세한 정보를 원하시면 라우터<!-- (???) -->에 대한 장을 참조하시기 바랍니다.

## 컨트롤러 액션{: #controller_action}

이제 요청은 컨트롤러 메소드로 디스패치됩니다.
예를 들어: ``Articles``컨트롤러의 ``show``메소드/액션있다고 해봅시다.
이 액션은 뷰를 렌더하거나 그냥 간단히 스트링을 리턴할 수 있겠습니다.
메소드에 의해 리턴된 값은 Rack 응답을 만들기 위해 사용될 것입니다.
Rack 응답은 그냥 [status, headers, body]를 담고 있는 간단한 튜플입니다.

## 문 밖{: #out_the_door}

마지막으로 Merb는 모양이 잘 잡힌 Rack 응답을 웹서버로 돌려보낼 것입니다.
웹서버는 그에 대해서, 와이어를 통해 나갈 HTTP 응답을 포메팅합니다.
그리고 클라이언트가 그 응답을 받아 해석하고, 예를 들면 웹페이지를 화면에 뿌려줄 것입니다.


## 캐싱{: #caching}

캐싱이 활성화되면 위에서 언급한 전체 프로세스를 통해 요청이 진행되지 않을 것입니다.
캐싱은 Merb, Rack 미들웨어, 프록시 서버, 클라이언트의 웹브라우저 등에서 일어날 수 있습니다.


<!-- Links -->
[Apache]:             http://httpd.apache.org/
[GlassFish]:          /deployment/jruby
[mod\_proxy]:         http://httpd.apache.org/docs/2.0/mod/mod_proxy.html
[Mongrel]:            http://mongrel.rubyforge.org/
[MVC]:                /getting-started/mvc
[NginX]:              /deployment/nginx
[Phusion Passenger]:  /deployment/passenger
[Rack]:               http://rack.rubyforge.org/
[Thin]:               http://code.macournoyer.com/thin/
